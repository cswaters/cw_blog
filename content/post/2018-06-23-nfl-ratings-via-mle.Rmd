---
title: NFL Ratings via MLE
author: Cory Waters
date: '2018-06-23'
slug: nfl-ratings-via-mle
categories:
  - betting
  - R
tags:
  - NFL
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
library(tidyverse)
library(alabama)
```

## Rating NFL Teams - Wayne Winston's method

In [Wayne Winston's book Mathletics](https://www.amazon.com/Mathletics-Gamblers-Enthusiasts-Mathematics-Basketball/dp/0691154589) he devotes a chapter to "Rating Sports Teams." This technique is also covered in a couple of his other wonderful excel books. The technique is covered (less thorougly) in an older article avaiable on the [Office site, titled "Using Solver to Rate Sports Teams"](https://support.office.com/en-us/article/Using-Solver-to-rate-sports-teams-f063257d-1008-46b7-8811-c723c64a7651).

Let's implement a very simple version of this in R. I'm not an optimization expert. After digging around the [CRAN task view for optimization](https://cran.r-project.org/web/views/Optimization.html) I settled on the package [alabama](https://cran.r-project.org/web/packages/alabama/index.html) package. Mainly because it was simple to use, nonlinear, and allowed for different types of constraints.

## Creating the model

Read the article to get an idea of the procedure we're going to use to come up with our ratings. 

Here's a summary:

1. Get scores for this NFL season. We're going to put them in a dataframe.
2. Create a ratings vector for each team and enter a "guess" for each team's rating. This doesn't need to be close as the optimization will find the ratings that best explain this season's results. To start, we'll use 0 for each team.
3. Create a "forecast" vector (or column). This forecast is the number of points we expect the home team to defeat the visitor by. (If this number is negative we expect the home team to lose. The formula we're using for the forecast is `Home Edge + Home Team Rating - Away Team Rating`. `Home Edge` is the home field advantage. The standard NFL home field advantage is 3, but we'll let the model determine the optimal value.
4. Subtract the forecast from the actual score for each game. Call this the residual. To start square these results to avoid the negative residuals from canceling out positive ones.
5. Minimize the sum of the squared residual vector.

That's the basic idea. We'll fill in with more detail when it's required.

Let's code it up.

## The code

We're going to NFL scores for this season. NFL scores are some of the easiest sporting data to find. We're going to use the data provided by Nate Silver's [Fivethirtyeight.com](https://fivethirtyeight.com). They make this (and past) season's scores available for their [ELO project on github](https://github.com/fivethirtyeight/nfl-elo-game).

```{r data_import, message=FALSE}
library(tidyverse)
nfl_scores_url <- 'https://projects.fivethirtyeight.com/nfl-api/2017/nfl_games_2017.csv'
nfl <- read_csv(nfl_scores_url)
glimpse(nfl)
```

### Cleaning up the data

There's some housekeeping necassary before we start coding the model.

+ All the games are in the 2017 season. Therefore no need for a season column.
+ Get rid of the ELO rating and probability columns.
+ There's still weeks before the playoffs so that column isn't important.
+ Scores will do, no need for the result column.

Games on neutral fields should alter the forecast formula, there's no home field advantage. 

We're keeping the following columns:

+ `date`
+ `neutral`
+ `team1` and `team2` but changing the names to `home` and `away`
+ `score1` and `score2` but changing the names to `h_score` and `a_score`

The data doesn't specify which team is home but a quick look at [week one's scores](http://www.nfl.com/scores/2017/REG1) show that `team1` and `score1` is the home team and score. Changing the column names isn't necassary but you'll be glad you did next season if you come back to the script. It's one less thing to remember/look up.

Add a margin of victory column for the home team. We're going to need this later.

```{r}
games <- nfl %>%  # remove future games
  select(date, 
         neutral, 
         home = team1, 
         away = team2, 
         h_score = score1, 
         a_score = score2) %>% 
  mutate(h_mov = h_score - a_score)
```

Let's look at those neutral games.

```{r}
paste("There was", 
      nrow(games),
      "games played in 2017.",
      sum(games$neutral),
      "of those games were played on a neutral field.")
  
```

`r sum(games$neutral)` shouldn't have a huge impact. It's a little less than three percent of games. We'll test that theory. First we'll ignore neutral games.

Create the basic forecast function. Remember the formula is `Home Edge + Home Team Rating - Away Team Rating`.

```{r forecast_func}
home_forecast <- function(home_rating,
                          visitor_rating,
                          home_edge) {
                          (home_edge + home_rating) - visitor_rating
                          }
```

### Create the ratings vector

Create a vector consisting of every team in the NFL.

```{r}
teams <- sort(unique(games$home))
length(teams) == 32 # there's 32 NFL teams
```

To start each team will be given a rating of zero. We're also going to add an extra zero to represent the home field "edge" or advantage. Finally, add the team names to the ratings vector. This is for matching and updating ratings (discussed later).

```{r ratings_vector}
ratings <- rep(0,33)
names(ratings) <- c(teams, 'hfa') # hfa = home field advantage
```

### The loss function

`constrOptim.nl` is the function from the `alabama` package that will perform the optimization. The function's argument `fn` is a 

> Nonlinear objective function that is to be optimized. A scalar function that takes a real vector as argument and returns a scalar that is the value of the function at that point.

In other words, we need to create a function that sums the squared errors between the forecast and actual game scores. `constrOptim.nl` minimizes this number by trying out different team ratings. When a minimum is reached the algorithm will stop and we can access the team ratings that best explain the results so far this season.

The function is simple. Pass in the team ratings as the argument. The forecast for each game is calculated via the `home_forecast` function. Each team's rating is looked up by passing the `home` and `away` columns to ratings vector matching the `ratings` names to the value in the columns. The home field edge is matched up with the 33rd element in the `ratings` vector. Next, a error column named `resid` subtracts the forecast from the home team's margin of victory, this value is squared. All of the squared errors are summed up in the `summarise` function in the column `sse`. That scalar value is returned. This returned value is the number `constrOptim.nl` will attempt to minimize.

```{r}
sqr_err <- function(ratings) {
  games %>%
    mutate(forecast = home_forecast(ratings[home],
                                    ratings[away],
                                    ratings[33])) %>% # 33 is the hfa
    mutate(resid = (h_mov - forecast) ^ 2) %>%
    summarise(sse = sum(resid)) %>% 
    pull(sse)
}
```

### The constraints

Winston's article suggests setting up a constraint in excel's solver.

> It is convenient to make our average team rating equal to 0. A team with a positive rating is better than average and a team with a negative rating is worse than average. 

`alabama`'s way of doing this feels a little akward to me but it works. We need the mean of the team ratings vector to equal zero when the optimization is complete. Remember that the `ratings` vector includes the hfa. That needs to be removed from the calculation.

`alabama` makes us place this constraint in a function. Because our constraint is that the team ratings must average to zero the function must be passed via the `heq` argument. 

> a vector function specifying equality constraints such that heq[j] = 0 for all j

The structure of this function is taken directly from the `alabama` documentation.

```{r setting_up_constraint}
set_team_avg_zero <- function(ratings){
  h <- rep(NA, 1)
  h[1] <- mean(ratings[-33])
  h
}

set_team_avg_zero(ratings)
```

It's not too tough to parse out what's going on. Inside the function `h` is a vector of constraints. Assign the equality, i.e. this value on the right hand side of the assignment arrow must equal zero. Return the vector of constraints.


### Run the model

From here it's easy. We need to pass `constrOptim.nl` three arguments.

1. `par` starting vector of parameter values. The `ratings` vector.
2. `fn` function that is to be optimized. The `sqr_err` function.
3. `heq` a vector function specifying equality constraints. The `set_team_avg_zero` function.

There's a lot of message output with `constrOptim.nl`. To save space I'll surpress it here. There's nothing we can't get out ourselves later.

*note: when you run this on your own computer it will take a minute.*

```{r run_model, message=FALSE}
mod <- constrOptim.nl(par = ratings,
                      fn = sqr_err,
                      heq = set_team_avg_zero)
```

`mod` is a list of six items. The item we're interested is `$par`

```{r}
(sse_ratings <- mod$par)
```

These are our team ratings. According to the model this season's home field advantage is `r sse_ratings[33]` points. If we want to get the rankings we sort the vector is descending order.

Here's the top 10 teams in the NFL by our rating system.

```{r}
tibble(teams = names(sse_ratings),
       rankings = sse_ratings) %>% 
  arrange(desc(rankings)) %>% 
  head(10) %>% 
  kable()
```

There's a couple surprises. New Orleans is ranked second and Jaguars ranked lower than I'd expect but it's standard looking top ten.

### What about the neutral games?

Remember we're ignoring the fact that four of the games were played on a neutral field. Does accounting for neutral games improve the model? 

```{r}
paste("As of now the SSE is", round(mod$value,3))
```

To factor in neutral games we need to alter the forecast function

```{r}
home_forecast_neutral <- function(home_rating,
                                  visitor_rating,
                                  home_edge,
                                  is_neutral) {
                                  ifelse(is_neutral,
                                  home_rating - visitor_rating,
                                  (home_edge + home_rating) - visitor_rating)
                                  }
```

The code above checks if a game is neutral. If it is the home edge is removed from the formula otherwise it's the same as before.

We also need to change the loss function.

```{r}
sqr_err_neutral <- function(ratings) {
  games %>%
    mutate(forecast = home_forecast_neutral(ratings[home],
                                    ratings[away],
                                    ratings[33],
                                    neutral)) %>% # 33 is the hfa
    mutate(resid = (h_mov - forecast) ^ 2) %>%
    summarise(sse = sum(resid)) %>% 
    pull(sse)
}
```

Let's create a new ratings vector.

```{r}
neutral_ratings <- rep(0,33)
names(neutral_ratings) <- c(teams, 'hfa') # hfa = home field advantage
```


Now we can re-run the model.


```{r run_model_neutral, message=FALSE}
mod_neutral <- constrOptim.nl(par = neutral_ratings,
                      fn = sqr_err_neutral,
                      heq = set_team_avg_zero)
```

The differnce between the two models isn't worth the extra effort IMO.

```{r}
tibble(with_neutral_mod = mod_neutral$value,
       without_netural_mod = mod$value) %>% 
  kable()
```


I'll leave it up to you to see if there's substanial differences in ranking.

### Point Spreads

While it's interesting to compare results to other rating systems we're really interested in predictions the model makes.

To do this we'll create a function that predicts the home team's margin of victory by sticking the `home_forecast` function inside another function.

```{r}
get_pointspred <- function(ratings, home, away){
  home_forecast(ratings[home],
                ratings[away],
                ratings['hfa']) %>% 
    round(2)
}
```

Below is an example how you could use the ratings to predict point spreads. Obviously you want to predict games in the future but it works for an illustration.

```{r}
nfl %>% 
  filter(date == '2018-02-04') %>% 
  select(date, home = team1, away = team2) %>% 
  mutate(spread = get_pointspred(mod$par, home, away)) %>% 
  kable()
```

